<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Week 6</title>
<meta name="author" content="(Matthew Woodward)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://robojackets.github.io/reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="https://robojackets.github.io/reveal.js/css/theme/white.css" id="theme"/>


<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'https://robojackets.github.io/reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Week 6</h1>
</section>

<section id="slide-orgabdc71a">
<h2 id="orgabdc71a">What are we doing today?</h2>
<ul>
<li>Const Keyword</li>
<li>Initializer Lists</li>
<li>Header Guards</li>
<li>More STL
<ul>
<li>Functors</li>
<li>Lambdas</li>
<li>Predicates</li>

</ul></li>

</ul>

</section>
<section id="slide-org209e5f2">
<h2 id="org209e5f2">Const Keyword</h2>
<ul>
<li>Can be used on both variables and member functions of objects
<ul>
<li>Const Variable
<ul>
<li>Makes the value <i>constant</i> as the name implies</li>
<li>Must be initialized when declared</li>
<li>This can also be applied to the arguments and return type of a function</li>

</ul></li>
<li>Const Member Function
<ul>
<li>Makes the member function read-only</li>
<li>It can only read and return values, it cannot change any of the members of the class</li>

</ul></li>

</ul></li>

</ul>

</section>
<section id="slide-org20a2235">
<h3 id="org20a2235">Constant Variables</h3>
<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #598249;">int</span> <span style="color: #2F7BDE;">main</span>() {
    <span style="color: #598249;">const</span> <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span>; <span style="color: #5e6263;">// </span><span style="color: #5e6263;">This causes an error</span>

    <span style="color: #598249;">const</span> <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span> = 0; <span style="color: #5e6263;">// </span><span style="color: #5e6263;">This is correct</span>

    <span style="color: #598249;">return</span> 0;
}
</code></pre>
</div>
<p>
<a href="https://ideone.com/4D2EoC">Example</a>
</p>

</section>
<section id="slide-org400c9bf">
<h3 id="org400c9bf">Constant Arguments</h3>
<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #598249;">int</span> <span style="color: #2F7BDE;">constantArguments</span>(<span style="color: #598249;">const</span> <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span>) {
    <span style="color: #15968D;">std</span>::cout &lt;&lt; x &lt;&lt; <span style="color: #15968D;">std</span>::endl; <span style="color: #5e6263;">// </span><span style="color: #5e6263;">This is fine</span>
    x = 5; <span style="color: #5e6263;">// </span><span style="color: #5e6263;">This causes an error</span>

    <span style="color: #598249;">return</span> x;
}
</code></pre>
</div>

</section>
<section id="slide-org7405df6">
<h3 id="org7405df6">Constant Member Functions</h3>
<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #598249;">class</span> <span style="color: #598249;">Example</span> {
<span style="color: #598249;">public</span>:
    <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span>;
    <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">GetX</span>() <span style="color: #598249;">const</span>; <span style="color: #5e6263;">//</span><span style="color: #5e6263;">GetX is a constant member function</span>
};
</code></pre>
</div>
<p>
<a href="https://ideone.com/I854Gu">Example</a>
</p>

</section>
<section id="slide-org03bd69c">
<h3 id="org03bd69c">Why is this useful?</h3>
<ul>
<li>Good coding practice
<ul>
<li>Makes it clear what should and should not change</li>
<li>Prevents others from accidentally changing something</li>

</ul></li>
<li>More Efficient
<ul>
<li>The compiler can optimize aggresively around constant variables since they don't change</li>

</ul></li>

</ul>


</section>
<section id="slide-org7a2a284">
<h2 id="org7a2a284">Initializer Lists</h2>
<aside class="notes">
<p>
Describe what the below code does. Want to give a basic understanding of what it does
before trying to explain why they are useful
</p>

</aside>

<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #598249;">class</span> <span style="color: #598249;">Example</span> {
<span style="color: #598249;">public</span>:
    <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span>;
    <span style="color: #598249;">ClassA</span> <span style="color: #2F7BDE;">obj1</span>;
    <span style="color: #598249;">ClassB</span> <span style="color: #2F7BDE;">obj2</span>;

    <span style="color: #2F7BDE;">Example</span>(<span style="color: #598249;">int</span> <span style="color: #2F7BDE;">xValue</span>, <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">arg1</span>, <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">arg2</span>) : x(xValue), obj1(arg2), obj2(arg1, arg2) {
</code></pre>
</div>


</section>
<section id="slide-org6bd3d21">
<h3 id="org6bd3d21">Benefits of Initializer Lists</h3>
<ul>
<li>Initializes the member variables before the object is constructed
<ul>
<li>This allows you to have your member objects initialized before your constructor runs</li>
<li>It also allows you to have const member variables since they would otherwise error when you try to declare them without a value</li>

</ul></li>

</ul>

</section>
<section id="slide-org82337d3">
<h3 id="org82337d3">Initiliazing Constant Member Variables</h3>
<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #598249;">class</span> <span style="color: #598249;">Example</span> {
<span style="color: #598249;">public</span>:
    <span style="color: #598249;">const</span> <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span>;
    <span style="color: #2F7BDE;">Example</span>() {
        x = 5; <span style="color: #5e6263;">//</span><span style="color: #5e6263;">This causes an error since you can't "change" the value of a const</span>
    }
}
</code></pre>
</div>
<ul>
<li>You can't set the value of a constant variable after it has been declared</li>

</ul>

<aside class="notes">
<p>
Someone check me on that second statement
</p>

</aside>

</section>
<section id="slide-orgd7b2d84">
<h3 id="orgd7b2d84">Initiliazing Constant Member Variables pt. 2</h3>
<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #598249;">class</span> <span style="color: #598249;">Example</span> {
<span style="color: #598249;">public</span>:
    <span style="color: #598249;">const</span> <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span>;
    <span style="color: #2F7BDE;">Example</span>() : x(5);
}
</code></pre>
</div>
<ul>
<li>This works because the initialization chain intializes the constant variable before the object is constructed so it runs before the value of the const is frozen</li>
<li>This is also preferred over initializing the constant in the declaration of the class (<code>const int x = 5</code>)</li>

</ul>
</section>
<section id="slide-org3336922">
<h3 id="org3336922">Default Constructors with Custom Default Values</h3>
<ul>
<li>When a default constructor runs it calls the default constructors of all of the member variables</li>
<li>But sometimes you want your class to have different default values than the standard default constructors of its members</li>

</ul>

</section>
<section id="slide-orgf35e275">
<h3 id="orgf35e275">The Inefficient way to set default values</h3>
<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #598249;">class</span> <span style="color: #598249;">Example</span> {
<span style="color: #598249;">public</span>:
    <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span>;
    <span style="color: #598249;">ClassA</span> <span style="color: #2F7BDE;">object1</span>;
    <span style="color: #2F7BDE;">Example</span>() {
        x = 5;
        object1.field1 = 1;
        object1.field2 = 2;
    }
}
</code></pre>
</div>
<ul>
<li>This is inefficient because the default constructors of the objects are called first
<ul>
<li>This doesn't really matter for a primitive data type like an int but it could have a larger impact when called for more complex classes</li>

</ul></li>

</ul>

</section>
<section id="slide-org5135f0a">
<h3 id="org5135f0a">The Efficient way to set default values</h3>
<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #598249;">class</span> <span style="color: #598249;">Example</span> {
    <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span>;
    <span style="color: #598249;">ClassA</span> <span style="color: #2F7BDE;">object1</span>;
    <span style="color: #2F7BDE;">Example</span>() : x(5), object1(1,2){}
}
</code></pre>
</div>
<ul>
<li>This is more efficient because the member variables' constructors are called first so the default constructors are not also called
<ul>
<li>This does assume that object1 has a constructor to set field1 and field 2 though</li>

</ul></li>

</ul>

</section>
<section id="slide-org13ae960">
<h2 id="org13ae960">Header Guards</h2>
<aside class="notes">
<p>
Go to the next slide to illustrate the issue
</p>

</aside>

<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #5e6263;">//</span><span style="color: #5e6263;">in file: "example.cpp"</span>
<span style="color: #598249;">class</span> <span style="color: #598249;">Example</span> {
    <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span>;
}
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #5e6263;">//</span><span style="color: #5e6263;">in file: "b.cpp"</span>
<span style="color: #598249;">#include</span> <span style="color: #15968D;">"example.cpp"</span>
<span style="color: #598249;">class</span> <span style="color: #598249;">B</span> {
    <span style="color: #598249;">Example</span> <span style="color: #2F7BDE;">y</span>;
}
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #5e6263;">//</span><span style="color: #5e6263;">in file: "main.cpp"</span>
<span style="color: #598249;">#include</span> <span style="color: #15968D;">"example.cpp"</span>
<span style="color: #598249;">#include</span> <span style="color: #15968D;">"b.cpp"</span>

<span style="color: #598249;">int</span> <span style="color: #2F7BDE;">main</span>() {
    <span style="color: #598249;">Example</span> <span style="color: #2F7BDE;">obj1</span>;
    <span style="color: #598249;">B</span> <span style="color: #2F7BDE;">obj2</span>;

    <span style="color: #598249;">return</span> 0;
}
</code></pre>
</div>

<ul>
<li>Question: Why does this code cause an error?</li>

</ul>

</section>
<section id="slide-org723acea">
<h3 id="org723acea">Header Guards pt. 2</h3>
<aside class="notes">
<p>
Include statments aren't "run"&#x2026; anybody have a better term for this?
</p>

</aside>

<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #5e6263;">//</span><span style="color: #5e6263;">in file: "main.cpp" after include statments are run</span>

<span style="color: #598249;">class</span> <span style="color: #598249;">Example</span> {
    <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span>;
}

<span style="color: #598249;">class</span> <span style="color: #598249;">Example</span> {
    <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span>;
}

<span style="color: #598249;">class</span> <span style="color: #598249;">B</span> {
    <span style="color: #598249;">Example</span> <span style="color: #2F7BDE;">y</span>;
}

<span style="color: #598249;">int</span> <span style="color: #2F7BDE;">main</span>() {
    <span style="color: #598249;">Example</span> <span style="color: #2F7BDE;">obj1</span>;
    <span style="color: #598249;">B</span> <span style="color: #2F7BDE;">obj2</span>;

    <span style="color: #598249;">return</span> 0;
}
</code></pre>
</div>


</section>
<section id="slide-org34564c6">
<h3 id="org34564c6">Header Guards pt. 3</h3>
<ul>
<li>Example is defined twice and the compiler doesn't know which one to use</li>
<li>Header guards prevent header files (the .h files that we use to declare classes) from conflicting with themselves by only including the code once</li>

</ul>

</section>
<section id="slide-org5ae8d34">
<h3 id="org5ae8d34">Header Guard Syntax</h3>
<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #5e6263;">//</span><span style="color: #5e6263;">in file: "example.h"</span>
<span style="color: #598249;">#if</span><span style="color: #598249;">n</span><span style="color: #598249;">def</span> EXAMPLE_H
<span style="color: #598249;">#define</span> <span style="color: #2F7BDE;">EXAMPLE_H</span>
<span style="color: #598249;">class</span> <span style="color: #598249;">Example</span> {
    <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span>;
}
<span style="color: #598249;">#endif</span>
</code></pre>
</div>

<ul>
<li><code>#</code>   indicates a Preprocessor Directive. These alter the source code as it is passed into the compiler
<ul>
<li><code>#include</code>   copies the code from the indicated source and pastes it where the include was called</li>
<li><code>#ifndef</code>    checks if the given macro is not defined</li>
<li><code>#define</code>    defines the given macro</li>
<li><code>#endif</code>     closes the if statement started by #ifndef</li>

</ul></li>

</ul>

</section>
<section id="slide-orga2f81b8">
<h3 id="orga2f81b8">Header Guard Syntax pt. 2</h3>
<ul>
<li>Header guards work by only allowing the compiler to see the code inside the ifndef if the given macro is not yet defined.
After the compiler has processed the .h file once the <code>EXAMPLE_H</code> macro is defined so the next time it attempts to include the file the code is hidden inside the if statement</li>
<li>Almost every compiler also supports the command  <code>#pragma once</code> which does the same thing as the header guard although it is not technically part of the C++ standard</li>

</ul>


</section>
<section id="slide-orgebd7eae">
<h2 id="orgebd7eae">Functors</h2>
<ul>
<li>A functor is basically an object with the operator() which allows it to be called like a function</li>
<li>This allows us to create a "function" that can store data or use more information than its input arguments would otherwise allow</li>

</ul>
</section>
<section id="slide-org9ca4c2e">
<h3 id="org9ca4c2e">Functor Example</h3>
<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #598249;">class</span> <span style="color: #598249;">increment</span> {
<span style="color: #598249;">public</span>:
    <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">num</span>;
    <span style="color: #2F7BDE;">increment</span>(<span style="color: #598249;">int</span> <span style="color: #2F7BDE;">n</span>) : num(n){}

    <span style="color: #5e6263;">// </span><span style="color: #5e6263;">This allows the functor to be called using () like a function</span>
    <span style="color: #598249;">int</span> <span style="color: #598249;">operator</span> <span style="color: #2F7BDE;">()</span> (<span style="color: #598249;">int</span> <span style="color: #2F7BDE;">numIn</span>) <span style="color: #598249;">const</span> {
        <span style="color: #598249;">return</span> numIn + num;
    }
};

<span style="color: #598249;">int</span> <span style="color: #2F7BDE;">main</span>() {
    <span style="color: #598249;">increment</span> <span style="color: #2F7BDE;">exampleFunctor</span>(2);
    <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span> = 5;
    <span style="color: #15968D;">std</span>::cout &lt;&lt; exampleFunctor(5) &lt;&lt; <span style="color: #15968D;">std</span>::endl <span style="color: #5e6263;">// </span><span style="color: #5e6263;">Outputs 7</span>
    <span style="color: #598249;">return</span> 0;
}
</code></pre>
</div>

</section>
<section id="slide-org9c78e6b">
<h3 id="org9c78e6b">Lambdas</h3>
<ul>
<li>A lambda expression basically writes a short inline function</li>
<li>Syntax:</li>

</ul>
<pre  class="example">
[capture clause] (arguments) -&gt; return-type
{
    Definition of method
}
</pre>
</section>
<section id="slide-org5a8f8b6">
<h3 id="org5a8f8b6">Syntax Breakdown</h3>
<ul>
<li>Most of the syntax works as it does in a function</li>
<li>Arguments: the list of input arguments (ex: int a, double b,&#x2026;)</li>
<li>Return-type: The type that the function returns (ex: bool)
<ul>
<li>Usually the arrow and return-type can be ommited since the compiler can figure it out</li>

</ul></li>

</ul>
<pre  class="example">
[capture clause] (arguments) -&gt; return-type
{
    Definition of method
}
</pre>
</section>
<section id="slide-org9bbf79d">
<h3 id="org9bbf79d">Capture Clauses</h3>
<ul>
<li>It is important to note that although the lambda is defined inline the code still accesses it through a normal function call
<ul>
<li>This means that variables that were in the local scope before the lambda call are <i>not</i> in this scope</li>

</ul></li>
<li>In order to access these variables we have to tell the compiler how we want to access them</li>

</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Access Type</th>
<th scope="col" class="org-left">Capture Clause</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">By Reference</td>
<td class="org-left">[&amp;]</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">By Value</td>
<td class="org-left">[=]</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Individually specify</td>
<td class="org-left">[varA, &amp;varB]</td>
</tr>
</tbody>
</table>
</section>
<section id="slide-orgee151e0">
<h3 id="orgee151e0">Lambda Example</h3>
<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #598249;">#include</span> <span style="color: #15968D;">&lt;iostream&gt;</span>

<span style="color: #598249;">using</span> <span style="color: #598249;">namespace</span> <span style="color: #15968D;">std</span>;

<span style="color: #598249;">void</span> <span style="color: #2F7BDE;">print_sum</span>(<span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x1</span>, <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x2</span>) {
  cout &lt;&lt; x1 &lt;&lt; <span style="color: #15968D;">" + "</span> &lt;&lt; x2 &lt;&lt; <span style="color: #15968D;">" = "</span> &lt;&lt; x1 + x2 &lt;&lt; endl;
}

<span style="color: #598249;">int</span> <span style="color: #2F7BDE;">main</span>() {
  <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">calculated_value</span> = 10;

  <span style="color: #598249;">auto</span> <span style="color: #2F7BDE;">print_plus_calculated_val</span> = [&amp;<span style="color: #2F7BDE;">calculated_value</span>](<span style="color: #598249;">int</span> <span style="color: #2F7BDE;">x</span>) {
    print_sum(calculated_value, x);
  };

  <span style="color: #598249;">for</span> (<span style="color: #598249;">int</span> <span style="color: #2F7BDE;">i</span> = 0; i &lt; 5; i++) {
    print_plus_calculated_val(i);
  }
}
</code></pre>
</div>
<p>
<a href="https://ideone.com/i5U6hC">Example</a>
</p>
</section>
<section id="slide-orgf49db5b">
<h3 id="orgf49db5b">STL and Functors</h3>
<ul>
<li>Many STL algorithms accept functors and lambdas as their last argument</li>
<li>Types of Functors:
<ul>
<li>Generator: a Functor that takes no arguments</li>
<li>Unary Function: a Functor that can be called with one argument</li>
<li>Binary Function: a Functor that can be called with two arguments</li>

</ul></li>

</ul>
</section>
<section id="slide-orgac65823">
<h3 id="orgac65823">Predicates</h3>
<ul>
<li>A Predicate is a function or functor that returns a boolean value</li>
<li>A common use for predicates is to allow an STL algorithm to be applied only to the members of a container that meet the requirement of the Predicate</li>

</ul>
</section>
<section id="slide-org1cbf1d8">
<h3 id="org1cbf1d8"><code>count_if</code></h3>
<ul>
<li><code>count_if</code> is a STL function that counts the number of elements in a container that match the condition of the unary predicate it is given</li>
<li><code>count_if(InputIterator first, InputIterator last, UnaryPredicate pred)</code></li>

</ul>

</section>
<section id="slide-org979bfb1">
<h3 id="org979bfb1"><code>count_if</code> example</h3>
<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #598249;">#include</span> <span style="color: #15968D;">&lt;iostream&gt;</span>
<span style="color: #598249;">#include</span> <span style="color: #15968D;">&lt;vector&gt;</span>
<span style="color: #598249;">#include</span> <span style="color: #15968D;">&lt;algorithm&gt;</span>

<span style="color: #598249;">using</span> <span style="color: #598249;">namespace</span> <span style="color: #15968D;">std</span>;

<span style="color: #598249;">int</span> <span style="color: #2F7BDE;">main</span>() {
        <span style="color: #598249;">vector</span>&lt;<span style="color: #598249;">int</span>&gt; <span style="color: #2F7BDE;">x</span>{ 1, 2, 3, 4, 5, 6, 7, 8 };

        <span style="color: #598249;">int</span> <span style="color: #2F7BDE;">numOdd</span> = count_if(x.begin(), x.end(), [] (<span style="color: #598249;">int</span> <span style="color: #2F7BDE;">in</span>) {
                <span style="color: #598249;">return</span> in%2;
        });

        <span style="color: #15968D;">std</span>::cout&lt;&lt; <span style="color: #15968D;">"there were "</span> &lt;&lt; numOdd &lt;&lt; <span style="color: #15968D;">" odd numbers"</span> &lt;&lt; <span style="color: #15968D;">std</span>::endl;

        <span style="color: #598249;">return</span> 0;
}
</code></pre>
</div>
<p>
<a href="https://ideone.com/6wBPvF">Example</a>
</p>
</section>
<section id="slide-orgfbe05f4">
<h3 id="orgfbe05f4">transform</h3>
<ul>
<li>transform is a STL function that iterates through a given range applying the given Unary function and storing it in a second range
<ul>
<li>Useful hint: The output range can be the same as the input range causing transform to just overwrite each value</li>

</ul></li>
<li>transform(InputIterator first, InputIterator last, OutputIterator start, UnaryOperation op)</li>

</ul>

</section>
<section id="slide-org533ed9e">
<h3 id="org533ed9e">transform example</h3>
<div class="org-src-container">

<pre  class="src src-c++"><code trim><span style="color: #598249;">#include</span> <span style="color: #15968D;">&lt;algorithm&gt;</span>
<span style="color: #598249;">#include</span> <span style="color: #15968D;">&lt;iostream&gt;</span>
<span style="color: #598249;">#include</span> <span style="color: #15968D;">&lt;string&gt;</span>

<span style="color: #598249;">int</span> <span style="color: #2F7BDE;">main</span>()
{
    <span style="color: #15968D;">std</span>::<span style="color: #598249;">string</span> <span style="color: #2F7BDE;">s</span>(<span style="color: #15968D;">"hello world"</span>);

    <span style="color: #15968D;">std</span>::transform(s.begin(), s.end(), s.begin(),
        [](<span style="color: #598249;">char</span> <span style="color: #2F7BDE;">c</span>) { <span style="color: #598249;">return</span> <span style="color: #15968D;">std</span>::toupper(c); });

    <span style="color: #15968D;">std</span>::cout &lt;&lt; <span style="color: #15968D;">"s is: "</span> &lt;&lt; s &lt;&lt; <span style="color: #15968D;">std</span>::endl;

    <span style="color: #598249;">return</span> 0;
}
</code></pre>
</div>
<p>
<a href="https://ideone.com/RTQd7i">Example</a>
</p>
</section>
<section id="slide-orgc0752bf">
<h2 id="orgc0752bf">Exercise: Color Binning</h2>
<ol>
<li>Drive the light sensor across the series of strips recording all of the values seen</li>
<li>Use a STL function to replace each reading with the value of:
<ul>
<li>(the reading) / 256</li>
<li>This will sort the values into 16 categories ("bins")</li>

</ul></li>
<li>Use a for loop and another STL function to print the number of readings that fell into each category</li>

</ol>
</section>
</section>
</div>
</div>
<script src="https://robojackets.github.io/reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'https://robojackets.github.io/reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
]
});
</script>
</body>
</html>
