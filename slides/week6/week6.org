#+TITLE: Week 6
#+AUTHOR: Matthew Woodward
#+EMAIL: mwoodward@gatech.edu

* What are we doing today?
- Const Keyword
- Initializer Lists
- Header Guards
- More STL
 - Functors
 - Predicates
 - Lambdas

* Const Keyword
- Can be used on both variables and member functions of objects
 - Const Variable
  - Makes the value /constant/ as the name implies
  - Must be initialized when declared
  - This can also be applied to the arguments and return type of a function
 - Const Member Function
  - Makes the member function read-only
  - It can only read and return values, it cannot change any of the members of the class

** Constant Variables
#+BEGIN_SRC c++
int main() {
    const int x; // This causes an error

    const int x = 0; // This is correct

    return 0;
}
#+END_SRC
[[https://ideone.com/4D2EoC][Example]]

** Constant Arguments
#+BEGIN_SRC c++
int constantArguments(const int x) {
    std::cout << x << std::endl; // This is fine
    x = 5; // This causes an error

    return x;
}
#+END_SRC

** Constant Member Functions
#+BEGIN_SRC c++
class Example {
public:
    int x;
    int GetX() const; //GetX is a constant member function
};
#+END_SRC
[[https://ideone.com/pWIhi5][Example]]

** Why is this useful?
- Good coding practice
 - Makes it clear what should and should not change
 - Prevents others from accidentally changing something
- More Efficient
 - The compiler can optimize aggresively around constant variables since they don't change


* Initializer Lists
#+BEGIN_NOTES
Describe what the below code does. Want to give a basic understanding of what it does
before trying to explain why they are useful
#+END_NOTES

#+BEGIN_SRC c++
class Example {
public:
    int x;
    ClassA obj1;
    ClassB obj2;

    Example(int xValue, int arg1, int arg2) : x(xValue), obj1(arg2), obj2(arg1, arg2) {
#+END_SRC


** Benefits of Initializer Lists
- Initializes the member variables before the object is constructed
 - This allows you to have your member objects initialized before your constructor runs
 - It also allows you to have const member variables since they would otherwise error when you try to declare them without a value

** Initiliazing Constant Member Variables
#+BEGIN_SRC c++
class Example {
public:
    const int x;
    Example() {
        x = 5; //This causes an error since you can't "change" the value of a const
    }
}
#+End_SRC
- You can't set the value of a constant variable after it has been declared
- You also shouldn't (and couldn't until C++11) give the variable a value in the declaration of the class like you would normally initialize a const

#+BEGIN_NOTES
Someone check me on that second statement
#+END_NOTES

** Initiliazing Constant Member Variables pt. 2
#+BEGIN_SRC c++
class Example {
public:
    const int x;
    Example() : x(5);
}
#+End_SRC
- This works because the initialization chain intializes the constant variable before the object is constructed so it runs before the value of the const is frozen

** Default Constructors with Custom Default Values
- When a default constructor runs it calls the default constructors of all of the member variables
- But sometimes you want your class to have different default values than the standard default constructors of its members

** The Inefficient way to set default values
#+BEGIN_SRC c++
class Example {
public:
    int x;
    ClassA object1;
    Example() {
        x = 5;
        object1.field1 = 1;
        object1.field2 = 2;
    }
}
#+END_SRC
- This is inefficient because the default constructors of the objects are called first
 - This doesn't really matter for a primitive data type like an int but it could have a larger impact when called for more complex classes

** The Efficient way to set default values
#+BEGIN_SRC c++
class Example {
    int x;
    ClassA object1;
    Example() : x(5), object1(1,2){}
}
#+END_SRC
- This is more efficient because the member variables' constructors are called first so the default constructors are not also called
 - This does assume that object1 has a constructor to set field1 and field 2 though

* Header Guards

#+BEGIN_NOTES
Go to the next slide to illustrate the issue
#+END_NOTES

#+BEGIN_SRC c++
//in file: "example.cpp"
class Example {
    int x;
}
#+END_SRC

#+BEGIN_SRC c++
//in file: "b.cpp"
#include "example.cpp"
class B {
    Example y;
}
#+END_SRC

#+BEGIN_SRC c++
//in file: "main.cpp"
#include "example.cpp"
#include "b.cpp"

int main() {
    Example obj1;
    B obj2;

    return 0;
}
#+END_SRC

- Question: Why does this code cause an error?

** Header Guards pt. 2

#+BEGIN_NOTES
Include statments aren't "run"... anybody have a better term for this?
#+END_NOTES

#+BEGIN_SRC c++
//in file: "main.cpp" after include statments are run

class Example {
    int x;
}

class Example {
    int x;
}

class B {
    Example y;
}

int main() {
    Example obj1;
    B obj2;

    return 0;
}
#+END_SRC


** Header Guards pt. 3
- Example is defined twice and the compiler doesn't know which one to use
- Header guards prevent header files (the .h files that we use to declare classes) from conflicting with themselves by only including the code once

** Header Guard Syntax

#+BEGIN_SRC c++
//in file: "example.h"
#ifndef EXAMPLE_H
#define EXAMPLE_H
class Example {
    int x;
}
#endif
#+END_SRC

- ~#~   indicates a Preprocessor Directive. These alter the source code as it is passed into the compiler
 - ~#include~   copies the code from the indicated source and pastes it where the include was called
 - ~#ifndef~    checks if the given macro is not defined
 - ~#define~    defines the given macro
 - ~#endif~     closes the if statement started by #ifndef

** Header Guard Syntax pt. 2
- Header guards work by only allowing the compiler to see the code inside the ifndef if the given macro is not yet defined.
    After the compiler has processed the .h file once the ~EXAMPLE_H~ macro is defined so the next time it attempts to include the file the code is hidden inside the if statement
- Almost every compiler also supports the command  ~#pragma once~ which does the same thing as the header guard although it is not technically part of the C++ standard


* Functors
- A functor is basically an object with the operator() which allows it to be called like a function
- This allows us to create a "function" that can store data or use more information than its input arguments would otherwise allow
** Functor Example
#+BEGIN_SRC c++
class increment {
public:
    int num;
    increment(int n) : num(n){}

    // This allows the functor to be called using () like a function
    int operator () (int numIn) const {
        return numIn + num;
    }
};

int main() {
    increment exampleFunctor(2);
    int x = 5;
    std::cout << exampleFunctor(5) << std::endl // Outputs 7
    return 0;
}
#+END_SRC

** STL and Functors
- Many STL algorithms take a functor as their last argument
- Types of Functors:
 - Generator: a Functor that takes no arguments
 - Unary Function: a Functor that can be called with one argument
 - Binary Function: a Functor that can be called with two arguments
** Predicates
- A Predicate is a function or functor that returns a boolean value or an instance of an object with a bool operator()
- A common use for predicates is to allow an STL algorithm to be applied only to the members of a container that meet the requirement of the Predicate
** STL Algorithms
- This slide still needs content


* Exercise: Average light sensor values for white lines
1. Drive the light sensor across a series of strips recording all of the values seen
2. Use an STL function to remove all of the black values (value < 2000)
3. Return the average value of the remaining readings
